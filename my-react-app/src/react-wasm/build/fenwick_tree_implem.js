/* eslint-disable no-undef */
/* eslint-disable  no-restricted-globals */
/* eslint-disable import/no-amd */

var Module = (() => {
  var _scriptName = import.meta.url;

  return function (moduleArg = {}) {
    var moduleRtn;

    var Module = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve, reject) => {
      readyPromiseResolve = resolve;
      readyPromiseReject = reject;
    });
    var ENVIRONMENT_IS_WEB = true;
    var ENVIRONMENT_IS_WORKER = false;
    var moduleOverrides = Object.assign({}, Module);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = (status, toThrow) => {
      throw toThrow;
    };
    var scriptDirectory = "";
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location.href;
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.substr(
          0,
          scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1,
        );
      }
      {
        readAsync = (url) =>
          fetch(url, { credentials: "same-origin" }).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            }
            return Promise.reject(
              new Error(response.status + " : " + response.url),
            );
          });
      }
    } else {
    }
    var out = Module["print"] || console.log.bind(console);
    var err = Module["printErr"] || console.error.bind(console);
    Object.assign(Module, moduleOverrides);
    moduleOverrides = null;
    if (Module["arguments"]) arguments_ = Module["arguments"];
    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
    if (Module["quit"]) quit_ = Module["quit"];
    var wasmBinary;
    if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
    function intArrayFromBase64(s) {
      var decoded = atob(s);
      var bytes = new Uint8Array(decoded.length);
      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }
      return bytes;
    }
    function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }
      return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module["HEAP8"] = HEAP8 = new Int8Array(b);
      Module["HEAP16"] = HEAP16 = new Int16Array(b);
      Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module["HEAP32"] = HEAP32 = new Int32Array(b);
      Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
    }
    if (Module["wasmMemory"]) {
      wasmMemory = Module["wasmMemory"];
    } else {
      var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 1048576e3;
      wasmMemory = new WebAssembly.Memory({
        initial: INITIAL_MEMORY / 65536,
        maximum: 2097152e3 / 65536,
      });
    }
    updateMemoryViews();
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function")
          Module["preRun"] = [Module["preRun"]];
        while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true;
      callRuntimeCallbacks(__ATINIT__);
    }
    function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function")
          Module["postRun"] = [Module["postRun"]];
        while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function addRunDependency(id) {
      runDependencies++;
      Module["monitorRunDependencies"]?.(runDependencies);
    }
    function removeRunDependency(id) {
      runDependencies--;
      Module["monitorRunDependencies"]?.(runDependencies);
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    function abort(what) {
      Module["onAbort"]?.(what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      EXITSTATUS = 1;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,";
    var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
    function findWasmBinary() {
      var f =
        "data:application/octet-stream;base64,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Z25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50NjRfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AE5TdDNfXzI4b3B0aW9uYWxJZEVFAE5TdDNfXzIyN19fb3B0aW9uYWxfbW92ZV9hc3NpZ25fYmFzZUlkTGIxRUVFAE5TdDNfXzIyN19fb3B0aW9uYWxfY29weV9hc3NpZ25fYmFzZUlkTGIxRUVFAE5TdDNfXzIyMF9fb3B0aW9uYWxfbW92ZV9iYXNlSWRMYjFFRUUATlN0M19fMjIwX19vcHRpb25hbF9jb3B5X2Jhc2VJZExiMUVFRQBOU3QzX18yMjNfX29wdGlvbmFsX3N0b3JhZ2VfYmFzZUlkTGIwRUVFAE5TdDNfXzIyNF9fb3B0aW9uYWxfZGVzdHJ1Y3RfYmFzZUlkTGIxRUVFAAAAoCoAACAJAADIKgAA9wgAAEwJAADIKgAA0QgAAFQJAADIKgAAqwgAAGAJAADIKgAAfggAAGwJAADIKgAAUQgAAHgJAABOU3QzX18yMThfX3NmaW5hZV9jdG9yX2Jhc2VJTGIxRUxiMUVFRQAAoCoAAJAJAABOU3QzX18yMjBfX3NmaW5hZV9hc3NpZ25fYmFzZUlMYjFFTGIxRUVFAAAAAKAqAADACQAAJCsAADwIAAAAAAAAAwAAAIQJAAAAAAAAuAkAAAAAAADsCQAAAAAAAE5TdDNfXzI2dmVjdG9ySWROU185YWxsb2NhdG9ySWRFRUVFAKAqAAAcCgAAUE5TdDNfXzI2dmVjdG9ySWROU185YWxsb2NhdG9ySWRFRUVFAAAAAIArAABICgAAAAAAAEAKAABQS05TdDNfXzI2dmVjdG9ySWROU185YWxsb2NhdG9ySWRFRUVFAAAAgCsAAIAKAAABAAAAQAoAAHBwAHYAdnAAcAoAANwpAABwCgAAkCoAAHZwcGQAQeAVCzTcKQAAcAoAAGAqAACQKgAAdnBwcGQAAABgKgAAqAoAAHBwcAD0CQAAQAoAAGAqAABwcHBwAEGgFgsV9CkAAEAKAABgKgAAkCoAAGlwcHBkAEHAFguDAZAqAABACgAAPCoAADwqAAA8KgAAZHBwaWlpADEyZmVud2lja190cmVlAAAAoCoAAFsLAABQMTJmZW53aWNrX3RyZWUAgCsAAHQLAAAAAAAAbAsAAFBLMTJmZW53aWNrX3RyZWUAAAAAgCsAAJQLAAABAAAAbAsAAIQLAABACgAAcHBwAEHQFwsV3CkAAIQLAAA8KgAAkCoAAHZwcGlkAEHwFwugCJAqAACECwAAPCoAADwqAABkcHBpaQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAACgKgAABgwAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAACgKgAAUAwAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAACgKgAAmAwAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAAoCoAAOAMAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAKAqAAAsDQAATjEwZW1zY3JpcHRlbjN2YWxFAACgKgAAeA0AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAAoCoAAJQNAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAAKAqAAC8DQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAACgKgAA5A0AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQAAoCoAAAwOAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAAKAqAAA0DgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAACgKgAAXA4AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQAAoCoAAIQOAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAAKAqAACsDgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAACgKgAA1A4AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAAoCoAAPwOAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAAKAqAAAkDwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAACgKgAATA8AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAAoCoAAHQPAAAAAAAA/oIrZUcVZ0AAAAAAAAA4QwAA+v5CLna/OjuevJr3DL29/f/////fPzxUVVVVVcU/kSsXz1VVpT8X0KRnERGBPwAAAAAAAMhC7zn6/kIu5j8kxIL/vb/OP7X0DNcIa6w/zFBG0quygz+EOk6b4NdVPwBBniALwhDwP26/iBpPO5s8NTP7qT327z9d3NicE2BxvGGAdz6a7O8/0WaHEHpekLyFf27oFePvPxP2ZzVS0ow8dIUV07DZ7z/6jvkjgM6LvN723Slr0O8/YcjmYU73YDzIm3UYRcfvP5nT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";
      return f;
    }
    var wasmBinaryFile;
    function getBinarySync(file) {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      var binary = tryParseAsDataURI(file);
      if (binary) {
        return binary;
      }
      if (readBinary) {
        return readBinary(file);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    function getBinaryPromise(binaryFile) {
      return Promise.resolve().then(() => getBinarySync(binaryFile));
    }
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile)
        .then((binary) => WebAssembly.instantiate(binary, imports))
        .then(receiver, (reason) => {
          err(`failed to asynchronously prepare wasm: ${reason}`);
          abort(reason);
        });
    }
    function instantiateAsync(binary, binaryFile, imports, callback) {
      return instantiateArrayBuffer(binaryFile, imports, callback);
    }
    function getWasmImports() {
      return { a: wasmImports };
    }
    function createWasm() {
      var info = getWasmImports();
      function receiveInstance(instance, module) {
        wasmExports = instance.exports;
        wasmTable = wasmExports["v"];
        addOnInit(wasmExports["u"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      if (Module["instantiateWasm"]) {
        try {
          return Module["instantiateWasm"](info, receiveInstance);
        } catch (e) {
          err(`Module.instantiateWasm callback failed with error: ${e}`);
          readyPromiseReject(e);
        }
      }
      if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();
      instantiateAsync(
        wasmBinary,
        wasmBinaryFile,
        info,
        receiveInstantiationResult,
      ).catch(readyPromiseReject);
      return {};
    }
    var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module);
      }
    };
    var noExitRuntime = Module["noExitRuntime"] || true;
    var stackRestore = (val) => __emscripten_stack_restore(val);
    var stackSave = () => _emscripten_stack_get_current();
    class ExceptionInfo {
      constructor(excPtr) {
        this.excPtr = excPtr;
        this.ptr = excPtr - 24;
      }
      set_type(type) {
        HEAPU32[(this.ptr + 4) >> 2] = type;
      }
      get_type() {
        return HEAPU32[(this.ptr + 4) >> 2];
      }
      set_destructor(destructor) {
        HEAPU32[(this.ptr + 8) >> 2] = destructor;
      }
      get_destructor() {
        return HEAPU32[(this.ptr + 8) >> 2];
      }
      set_caught(caught) {
        caught = caught ? 1 : 0;
        HEAP8[this.ptr + 12] = caught;
      }
      get_caught() {
        return HEAP8[this.ptr + 12] != 0;
      }
      set_rethrown(rethrown) {
        rethrown = rethrown ? 1 : 0;
        HEAP8[this.ptr + 13] = rethrown;
      }
      get_rethrown() {
        return HEAP8[this.ptr + 13] != 0;
      }
      init(type, destructor) {
        this.set_adjusted_ptr(0);
        this.set_type(type);
        this.set_destructor(destructor);
      }
      set_adjusted_ptr(adjustedPtr) {
        HEAPU32[(this.ptr + 16) >> 2] = adjustedPtr;
      }
      get_adjusted_ptr() {
        return HEAPU32[(this.ptr + 16) >> 2];
      }
      get_exception_ptr() {
        var isPointer = ___cxa_is_pointer_type(this.get_type());
        if (isPointer) {
          return HEAPU32[this.excPtr >> 2];
        }
        var adjusted = this.get_adjusted_ptr();
        if (adjusted !== 0) return adjusted;
        return this.excPtr;
      }
    }
    var exceptionLast = 0;
    var uncaughtExceptionCount = 0;
    var ___cxa_throw = (ptr, type, destructor) => {
      var info = new ExceptionInfo(ptr);
      info.init(type, destructor);
      exceptionLast = ptr;
      uncaughtExceptionCount++;
      throw exceptionLast;
    };
    var __abort_js = () => {
      abort("");
    };
    var __embind_register_bigint = (
      primitiveType,
      name,
      size,
      minRange,
      maxRange,
    ) => {};
    var embind_init_charCodes = () => {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
        codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    };
    var embind_charCodes;
    var readLatin1String = (ptr) => {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
        ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    };
    var awaitingDependencies = {};
    var registeredTypes = {};
    var typeDependencies = {};
    var BindingError;
    var throwBindingError = (message) => {
      throw new BindingError(message);
    };
    var InternalError;
    var throwInternalError = (message) => {
      throw new InternalError(message);
    };
    var whenDependentTypesAreResolved = (
      myTypes,
      dependentTypes,
      getTypeConverters,
    ) => {
      myTypes.forEach(function (type) {
        typeDependencies[type] = dependentTypes;
      });
      function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
          throwInternalError("Mismatched type converter count");
        }
        for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach((dt, i) => {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);
          if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }
          awaitingDependencies[dt].push(() => {
            typeConverters[i] = registeredTypes[dt];
            ++registered;
            if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });
      if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    };
    function sharedRegisterType(rawType, registeredInstance, options = {}) {
      var name = registeredInstance.name;
      if (!rawType) {
        throwBindingError(
          `type "${name}" must have a positive integer typeid pointer`,
        );
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError(`Cannot register type '${name}' twice`);
        }
      }
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
      if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach((cb) => cb());
      }
    }
    function registerType(rawType, registeredInstance, options = {}) {
      if (!("argPackAdvance" in registeredInstance)) {
        throw new TypeError(
          "registerType registeredInstance requires argPackAdvance",
        );
      }
      return sharedRegisterType(rawType, registeredInstance, options);
    }
    var GenericWireTypeSize = 8;
    var __embind_register_bool = (rawType, name, trueValue, falseValue) => {
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        fromWireType: function (wt) {
          return !!wt;
        },
        toWireType: function (destructors, o) {
          return o ? trueValue : falseValue;
        },
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: function (pointer) {
          return this["fromWireType"](HEAPU8[pointer]);
        },
        destructorFunction: null,
      });
    };
    var shallowCopyInternalPointer = (o) => ({
      count: o.count,
      deleteScheduled: o.deleteScheduled,
      preservePointerOnDelete: o.preservePointerOnDelete,
      ptr: o.ptr,
      ptrType: o.ptrType,
      smartPtr: o.smartPtr,
      smartPtrType: o.smartPtrType,
    });
    var throwInstanceAlreadyDeleted = (obj) => {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
    };
    var finalizationRegistry = false;
    var detachFinalizer = (handle) => {};
    var runDestructor = ($$) => {
      if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    };
    var releaseClassHandle = ($$) => {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
        runDestructor($$);
      }
    };
    var downcastPointer = (ptr, ptrClass, desiredClass) => {
      if (ptrClass === desiredClass) {
        return ptr;
      }
      if (undefined === desiredClass.baseClass) {
        return null;
      }
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
        return null;
      }
      return desiredClass.downcast(rv);
    };
    var registeredPointers = {};
    var getInheritedInstanceCount = () =>
      Object.keys(registeredInstances).length;
    var getLiveInheritedInstances = () => {
      var rv = [];
      for (var k in registeredInstances) {
        if (registeredInstances.hasOwnProperty(k)) {
          rv.push(registeredInstances[k]);
        }
      }
      return rv;
    };
    var deletionQueue = [];
    var flushPendingDeletes = () => {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj["delete"]();
      }
    };
    var delayFunction;
    var setDelayFunction = (fn) => {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    };
    var init_embind = () => {
      Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
      Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
      Module["flushPendingDeletes"] = flushPendingDeletes;
      Module["setDelayFunction"] = setDelayFunction;
    };
    var registeredInstances = {};
    var getBasestPointer = (class_, ptr) => {
      if (ptr === undefined) {
        throwBindingError("ptr should not be undefined");
      }
      while (class_.baseClass) {
        ptr = class_.upcast(ptr);
        class_ = class_.baseClass;
      }
      return ptr;
    };
    var getInheritedInstance = (class_, ptr) => {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    };
    var makeClassHandle = (prototype, record) => {
      if (!record.ptrType || !record.ptr) {
        throwInternalError("makeClassHandle requires ptr and ptrType");
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError("Both smartPtrType and smartPtr must be specified");
      }
      record.count = { value: 1 };
      return attachFinalizer(
        Object.create(prototype, { $$: { value: record, writable: true } }),
      );
    };
    function RegisteredPointer_fromWireType(ptr) {
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
        this.destructor(ptr);
        return null;
      }
      var registeredInstance = getInheritedInstance(
        this.registeredClass,
        rawPointer,
      );
      if (undefined !== registeredInstance) {
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;
          registeredInstance.$$.smartPtr = ptr;
          return registeredInstance["clone"]();
        } else {
          var rv = registeredInstance["clone"]();
          this.destructor(ptr);
          return rv;
        }
      }
      function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this.pointeeType,
            ptr: rawPointer,
            smartPtrType: this,
            smartPtr: ptr,
          });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, {
            ptrType: this,
            ptr: ptr,
          });
        }
      }
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }
      var toType;
      if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
        rawPointer,
        this.registeredClass,
        toType.registeredClass,
      );
      if (dp === null) {
        return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
          smartPtrType: this,
          smartPtr: ptr,
        });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
          ptrType: toType,
          ptr: dp,
        });
      }
    }
    var attachFinalizer = (handle) => {
      if ("undefined" === typeof FinalizationRegistry) {
        attachFinalizer = (handle) => handle;
        return handle;
      }
      finalizationRegistry = new FinalizationRegistry((info) => {
        releaseClassHandle(info.$$);
      });
      attachFinalizer = (handle) => {
        var $$ = handle.$$;
        var hasSmartPtr = !!$$.smartPtr;
        if (hasSmartPtr) {
          var info = { $$: $$ };
          finalizationRegistry.register(handle, info, handle);
        }
        return handle;
      };
      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);
      return attachFinalizer(handle);
    };
    var init_ClassHandle = () => {
      Object.assign(ClassHandle.prototype, {
        isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          other.$$ = other.$$;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        },
        clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(
              Object.create(Object.getPrototypeOf(this), {
                $$: { value: shallowCopyInternalPointer(this.$$) },
              }),
            );
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        },
        delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = undefined;
            this.$$.ptr = undefined;
          }
        },
        isDeleted() {
          return !this.$$.ptr;
        },
        deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        },
      });
    };
    function ClassHandle() {}
    var createNamedFunction = (name, body) =>
      Object.defineProperty(body, "name", { value: name });
    var ensureOverloadTable = (proto, methodName, humanName) => {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        proto[methodName] = function (...args) {
          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
            throwBindingError(
              `Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`,
            );
          }
          return proto[methodName].overloadTable[args.length].apply(this, args);
        };
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    };
    var exposePublicSymbol = (name, value, numArguments) => {
      if (Module.hasOwnProperty(name)) {
        if (
          undefined === numArguments ||
          (undefined !== Module[name].overloadTable &&
            undefined !== Module[name].overloadTable[numArguments])
        ) {
          throwBindingError(`Cannot register public name '${name}' twice`);
        }
        ensureOverloadTable(Module, name, name);
        if (Module.hasOwnProperty(numArguments)) {
          throwBindingError(
            `Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`,
          );
        }
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        if (undefined !== numArguments) {
          Module[name].numArguments = numArguments;
        }
      }
    };
    var char_0 = 48;
    var char_9 = 57;
    var makeLegalFunctionName = (name) => {
      if (undefined === name) {
        return "_unknown";
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, "$");
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
        return `_${name}`;
      }
      return name;
    };
    function RegisteredClass(
      name,
      constructor,
      instancePrototype,
      rawDestructor,
      baseClass,
      getActualType,
      upcast,
      downcast,
    ) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
    var upcastPointer = (ptr, ptrClass, desiredClass) => {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError(
            `Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`,
          );
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
      }
      return ptr;
    };
    function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(
          `Cannot pass "${embindRepr(handle)}" as a ${this.name}`,
        );
      }
      if (!handle.$$.ptr) {
        throwBindingError(
          `Cannot pass deleted object as a pointer of type ${this.name}`,
        );
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        if (this.isSmartPointer) {
          ptr = this.rawConstructor();
          if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }
          return ptr;
        } else {
          return 0;
        }
      }
      if (!handle || !handle.$$) {
        throwBindingError(
          `Cannot pass "${embindRepr(handle)}" as a ${this.name}`,
        );
      }
      if (!handle.$$.ptr) {
        throwBindingError(
          `Cannot pass deleted object as a pointer of type ${this.name}`,
        );
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError(
          `Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`,
        );
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      if (this.isSmartPointer) {
        if (undefined === handle.$$.smartPtr) {
          throwBindingError("Passing raw pointer to smart pointer is illegal");
        }
        switch (this.sharingPolicy) {
          case 0:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError(
                `Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`,
              );
            }
            break;
          case 1:
            ptr = handle.$$.smartPtr;
            break;
          case 2:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle["clone"]();
              ptr = this.rawShare(
                ptr,
                Emval.toHandle(() => clonedHandle["delete"]()),
              );
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }
            break;
          default:
            throwBindingError("Unsupporting sharing policy");
        }
      }
      return ptr;
    }
    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError(`null is not a valid ${this.name}`);
        }
        return 0;
      }
      if (!handle.$$) {
        throwBindingError(
          `Cannot pass "${embindRepr(handle)}" as a ${this.name}`,
        );
      }
      if (!handle.$$.ptr) {
        throwBindingError(
          `Cannot pass deleted object as a pointer of type ${this.name}`,
        );
      }
      if (handle.$$.ptrType.isConst) {
        throwBindingError(
          `Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`,
        );
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
    function readPointer(pointer) {
      return this["fromWireType"](HEAPU32[pointer >> 2]);
    }
    var init_RegisteredPointer = () => {
      Object.assign(RegisteredPointer.prototype, {
        getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        },
        destructor(ptr) {
          this.rawDestructor?.(ptr);
        },
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: readPointer,
        fromWireType: RegisteredPointer_fromWireType,
      });
    };
    function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor,
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
          this["toWireType"] = constNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        } else {
          this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
          this.destructorFunction = null;
        }
      } else {
        this["toWireType"] = genericPointerToWireType;
      }
    }
    var replacePublicSymbol = (name, value, numArguments) => {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError("Replacing nonexistent public symbol");
      }
      if (
        undefined !== Module[name].overloadTable &&
        undefined !== numArguments
      ) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;
        Module[name].argCount = numArguments;
      }
    };
    var dynCallLegacy = (sig, ptr, args) => {
      sig = sig.replace(/p/g, "i");
      var f = Module["dynCall_" + sig];
      return f(ptr, ...args);
    };
    var wasmTable;
    var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
    var dynCall = (sig, ptr, args = []) => {
      if (sig.includes("j")) {
        return dynCallLegacy(sig, ptr, args);
      }
      var rtn = getWasmTableEntry(ptr)(...args);
      return rtn;
    };
    var getDynCaller =
      (sig, ptr) =>
      (...args) =>
        dynCall(sig, ptr, args);
    var embind__requireFunction = (signature, rawFunction) => {
      signature = readLatin1String(signature);
      function makeDynCaller() {
        if (signature.includes("j")) {
          return getDynCaller(signature, rawFunction);
        }
        return getWasmTableEntry(rawFunction);
      }
      var fp = makeDynCaller();
      if (typeof fp != "function") {
        throwBindingError(
          `unknown function pointer with signature ${signature}: ${rawFunction}`,
        );
      }
      return fp;
    };
    var extendError = (baseErrorType, errorName) => {
      var errorClass = createNamedFunction(errorName, function (message) {
        this.name = errorName;
        this.message = message;
        var stack = new Error(message).stack;
        if (stack !== undefined) {
          this.stack =
            this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
        }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function () {
        if (this.message === undefined) {
          return this.name;
        } else {
          return `${this.name}: ${this.message}`;
        }
      };
      return errorClass;
    };
    var UnboundTypeError;
    var getTypeName = (type) => {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    };
    var throwUnboundTypeError = (message, types) => {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
        if (seen[type]) {
          return;
        }
        if (registeredTypes[type]) {
          return;
        }
        if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);
          return;
        }
        unboundTypes.push(type);
        seen[type] = true;
      }
      types.forEach(visit);
      throw new UnboundTypeError(
        `${message}: ` + unboundTypes.map(getTypeName).join([", "]),
      );
    };
    var __embind_register_class = (
      rawType,
      rawPointerType,
      rawConstPointerType,
      baseClassRawType,
      getActualTypeSignature,
      getActualType,
      upcastSignature,
      upcast,
      downcastSignature,
      downcast,
      name,
      destructorSignature,
      rawDestructor,
    ) => {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(
        getActualTypeSignature,
        getActualType,
      );
      upcast &&= embind__requireFunction(upcastSignature, upcast);
      downcast &&= embind__requireFunction(downcastSignature, downcast);
      rawDestructor = embind__requireFunction(
        destructorSignature,
        rawDestructor,
      );
      var legalFunctionName = makeLegalFunctionName(name);
      exposePublicSymbol(legalFunctionName, function () {
        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [
          baseClassRawType,
        ]);
      });
      whenDependentTypesAreResolved(
        [rawType, rawPointerType, rawConstPointerType],
        baseClassRawType ? [baseClassRawType] : [],
        (base) => {
          base = base[0];
          var baseClass;
          var basePrototype;
          if (baseClassRawType) {
            baseClass = base.registeredClass;
            basePrototype = baseClass.instancePrototype;
          } else {
            basePrototype = ClassHandle.prototype;
          }
          var constructor = createNamedFunction(name, function (...args) {
            if (Object.getPrototypeOf(this) !== instancePrototype) {
              throw new BindingError("Use 'new' to construct " + name);
            }
            if (undefined === registeredClass.constructor_body) {
              throw new BindingError(name + " has no accessible constructor");
            }
            var body = registeredClass.constructor_body[args.length];
            if (undefined === body) {
              throw new BindingError(
                `Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`,
              );
            }
            return body.apply(this, args);
          });
          var instancePrototype = Object.create(basePrototype, {
            constructor: { value: constructor },
          });
          constructor.prototype = instancePrototype;
          var registeredClass = new RegisteredClass(
            name,
            constructor,
            instancePrototype,
            rawDestructor,
            baseClass,
            getActualType,
            upcast,
            downcast,
          );
          if (registeredClass.baseClass) {
            registeredClass.baseClass.__derivedClasses ??= [];
            registeredClass.baseClass.__derivedClasses.push(registeredClass);
          }
          var referenceConverter = new RegisteredPointer(
            name,
            registeredClass,
            true,
            false,
            false,
          );
          var pointerConverter = new RegisteredPointer(
            name + "*",
            registeredClass,
            false,
            false,
            false,
          );
          var constPointerConverter = new RegisteredPointer(
            name + " const*",
            registeredClass,
            false,
            true,
            false,
          );
          registeredPointers[rawType] = {
            pointerType: pointerConverter,
            constPointerType: constPointerConverter,
          };
          replacePublicSymbol(legalFunctionName, constructor);
          return [referenceConverter, pointerConverter, constPointerConverter];
        },
      );
    };
    var heap32VectorToArray = (count, firstElement) => {
      var array = [];
      for (var i = 0; i < count; i++) {
        array.push(HEAPU32[(firstElement + i * 4) >> 2]);
      }
      return array;
    };
    var runDestructors = (destructors) => {
      while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
      }
    };
    function usesDestructorStack(argTypes) {
      for (var i = 1; i < argTypes.length; ++i) {
        if (
          argTypes[i] !== null &&
          argTypes[i].destructorFunction === undefined
        ) {
          return true;
        }
      }
      return false;
    }
    function newFunc(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError(
          `new_ called with constructor type ${typeof constructor} which is not a function`,
        );
      }
      var dummy = createNamedFunction(
        constructor.name || "unknownFunctionName",
        function () {},
      );
      dummy.prototype = constructor.prototype;
      var obj = new dummy();
      var r = constructor.apply(obj, argumentList);
      return r instanceof Object ? r : obj;
    }
    function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
      var needsDestructorStack = usesDestructorStack(argTypes);
      var argCount = argTypes.length;
      var argsList = "";
      var argsListWired = "";
      for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;
        argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
      }
      var invokerFnBody = `\n        return function (${argsList}) {\n        if (arguments.length !== ${argCount - 2}) {\n          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${argCount - 2}');\n        }`;
      if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = [
        "humanName",
        "throwBindingError",
        "invoker",
        "fn",
        "runDestructors",
        "retType",
        "classParam",
      ];
      if (isClassMethodFunc) {
        invokerFnBody +=
          "var thisWired = classParam['toWireType'](" +
          dtorStack +
          ", this);\n";
      }
      for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody +=
          "var arg" +
          i +
          "Wired = argType" +
          i +
          "['toWireType'](" +
          dtorStack +
          ", arg" +
          i +
          ");\n";
        args1.push("argType" + i);
      }
      if (isClassMethodFunc) {
        argsListWired =
          "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
      invokerFnBody +=
        (returns || isAsync ? "var rv = " : "") +
        "invoker(fn" +
        (argsListWired.length > 0 ? ", " : "") +
        argsListWired +
        ");\n";
      if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
          if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += `${paramName}_dtor(${paramName});\n`;
            args1.push(`${paramName}_dtor`);
          }
        }
      }
      if (returns) {
        invokerFnBody +=
          "var ret = retType['fromWireType'](rv);\n" + "return ret;\n";
      } else {
      }
      invokerFnBody += "}\n";
      return [args1, invokerFnBody];
    }
    function craftInvokerFunction(
      humanName,
      argTypes,
      classType,
      cppInvokerFunc,
      cppTargetFunc,
      isAsync,
    ) {
      var argCount = argTypes.length;
      if (argCount < 2) {
        throwBindingError(
          "argTypes array size mismatch! Must at least get return value and 'this' types!",
        );
      }
      var isClassMethodFunc = argTypes[1] !== null && classType !== null;
      var needsDestructorStack = usesDestructorStack(argTypes);
      var returns = argTypes[0].name !== "void";
      var closureArgs = [
        humanName,
        throwBindingError,
        cppInvokerFunc,
        cppTargetFunc,
        runDestructors,
        argTypes[0],
        argTypes[1],
      ];
      for (var i = 0; i < argCount - 2; ++i) {
        closureArgs.push(argTypes[i + 2]);
      }
      if (!needsDestructorStack) {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          if (argTypes[i].destructorFunction !== null) {
            closureArgs.push(argTypes[i].destructorFunction);
          }
        }
      }
      let [args, invokerFnBody] = createJsInvoker(
        argTypes,
        isClassMethodFunc,
        returns,
        isAsync,
      );
      args.push(invokerFnBody);
      var invokerFn = newFunc(Function, args)(...closureArgs);
      return createNamedFunction(humanName, invokerFn);
    }
    var __embind_register_class_constructor = (
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor,
    ) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `constructor ${classType.name}`;
        if (undefined === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }
        if (
          undefined !== classType.registeredClass.constructor_body[argCount - 1]
        ) {
          throw new BindingError(
            `Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`,
          );
        }
        classType.registeredClass.constructor_body[argCount - 1] = () => {
          throwUnboundTypeError(
            `Cannot construct ${classType.name} due to unbound types`,
            rawArgTypes,
          );
        };
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          argTypes.splice(1, 0, null);
          classType.registeredClass.constructor_body[argCount - 1] =
            craftInvokerFunction(
              humanName,
              argTypes,
              null,
              invoker,
              rawConstructor,
            );
          return [];
        });
        return [];
      });
    };
    var getFunctionName = (signature) => {
      signature = signature.trim();
      const argsIndex = signature.indexOf("(");
      if (argsIndex !== -1) {
        return signature.substr(0, argsIndex);
      } else {
        return signature;
      }
    };
    var __embind_register_class_function = (
      rawClassType,
      methodName,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      rawInvoker,
      context,
      isPureVirtual,
      isAsync,
    ) => {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      methodName = getFunctionName(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
      whenDependentTypesAreResolved([], [rawClassType], (classType) => {
        classType = classType[0];
        var humanName = `${classType.name}.${methodName}`;
        if (methodName.startsWith("@@")) {
          methodName = Symbol[methodName.substring(2)];
        }
        if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }
        function unboundTypesHandler() {
          throwUnboundTypeError(
            `Cannot call ${humanName} due to unbound types`,
            rawArgTypes,
          );
        }
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (
          undefined === method ||
          (undefined === method.overloadTable &&
            method.className !== classType.name &&
            method.argCount === argCount - 2)
        ) {
          unboundTypesHandler.argCount = argCount - 2;
          unboundTypesHandler.className = classType.name;
          proto[methodName] = unboundTypesHandler;
        } else {
          ensureOverloadTable(proto, methodName, humanName);
          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
          var memberFunction = craftInvokerFunction(
            humanName,
            argTypes,
            classType,
            rawInvoker,
            context,
            isAsync,
          );
          if (undefined === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;
            proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }
          return [];
        });
        return [];
      });
    };
    var emval_freelist = [];
    var emval_handles = [];
    var __emval_decref = (handle) => {
      if (handle > 9 && 0 === --emval_handles[handle + 1]) {
        emval_handles[handle] = undefined;
        emval_freelist.push(handle);
      }
    };
    var count_emval_handles = () =>
      emval_handles.length / 2 - 5 - emval_freelist.length;
    var init_emval = () => {
      emval_handles.push(0, 1, undefined, 1, null, 1, true, 1, false, 1);
      Module["count_emval_handles"] = count_emval_handles;
    };
    var Emval = {
      toValue: (handle) => {
        if (!handle) {
          throwBindingError("Cannot use deleted val. handle = " + handle);
        }
        return emval_handles[handle];
      },
      toHandle: (value) => {
        switch (value) {
          case undefined:
            return 2;
          case null:
            return 4;
          case true:
            return 6;
          case false:
            return 8;
          default: {
            const handle = emval_freelist.pop() || emval_handles.length;
            emval_handles[handle] = value;
            emval_handles[handle + 1] = 1;
            return handle;
          }
        }
      },
    };
    var EmValType = {
      name: "emscripten::val",
      fromWireType: (handle) => {
        var rv = Emval.toValue(handle);
        __emval_decref(handle);
        return rv;
      },
      toWireType: (destructors, value) => Emval.toHandle(value),
      argPackAdvance: GenericWireTypeSize,
      readValueFromPointer: readPointer,
      destructorFunction: null,
    };
    var __embind_register_emval = (rawType) => registerType(rawType, EmValType);
    var embindRepr = (v) => {
      if (v === null) {
        return "null";
      }
      var t = typeof v;
      if (t === "object" || t === "array" || t === "function") {
        return v.toString();
      } else {
        return "" + v;
      }
    };
    var floatReadValueFromPointer = (name, width) => {
      switch (width) {
        case 4:
          return function (pointer) {
            return this["fromWireType"](HEAPF32[pointer >> 2]);
          };
        case 8:
          return function (pointer) {
            return this["fromWireType"](HEAPF64[pointer >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${width}): ${name}`);
      }
    };
    var __embind_register_float = (rawType, name, size) => {
      name = readLatin1String(name);
      registerType(rawType, {
        name: name,
        fromWireType: (value) => value,
        toWireType: (destructors, value) => value,
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: floatReadValueFromPointer(name, size),
        destructorFunction: null,
      });
    };
    var __embind_register_function = (
      name,
      argCount,
      rawArgTypesAddr,
      signature,
      rawInvoker,
      fn,
      isAsync,
    ) => {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = readLatin1String(name);
      name = getFunctionName(name);
      rawInvoker = embind__requireFunction(signature, rawInvoker);
      exposePublicSymbol(
        name,
        function () {
          throwUnboundTypeError(
            `Cannot call ${name} due to unbound types`,
            argTypes,
          );
        },
        argCount - 1,
      );
      whenDependentTypesAreResolved([], argTypes, (argTypes) => {
        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));
        replacePublicSymbol(
          name,
          craftInvokerFunction(
            name,
            invokerArgsArray,
            null,
            rawInvoker,
            fn,
            isAsync,
          ),
          argCount - 1,
        );
        return [];
      });
    };
    var integerReadValueFromPointer = (name, width, signed) => {
      switch (width) {
        case 1:
          return signed
            ? (pointer) => HEAP8[pointer]
            : (pointer) => HEAPU8[pointer];
        case 2:
          return signed
            ? (pointer) => HEAP16[pointer >> 1]
            : (pointer) => HEAPU16[pointer >> 1];
        case 4:
          return signed
            ? (pointer) => HEAP32[pointer >> 2]
            : (pointer) => HEAPU32[pointer >> 2];
        default:
          throw new TypeError(`invalid integer width (${width}): ${name}`);
      }
    };
    var __embind_register_integer = (
      primitiveType,
      name,
      size,
      minRange,
      maxRange,
    ) => {
      name = readLatin1String(name);
      if (maxRange === -1) {
        maxRange = 4294967295;
      }
      var fromWireType = (value) => value;
      if (minRange === 0) {
        var bitshift = 32 - 8 * size;
        fromWireType = (value) => (value << bitshift) >>> bitshift;
      }
      var isUnsignedType = name.includes("unsigned");
      var checkAssertions = (value, toTypeName) => {};
      var toWireType;
      if (isUnsignedType) {
        toWireType = function (destructors, value) {
          checkAssertions(value, this.name);
          return value >>> 0;
        };
      } else {
        toWireType = function (destructors, value) {
          checkAssertions(value, this.name);
          return value;
        };
      }
      registerType(primitiveType, {
        name: name,
        fromWireType: fromWireType,
        toWireType: toWireType,
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: integerReadValueFromPointer(
          name,
          size,
          minRange !== 0,
        ),
        destructorFunction: null,
      });
    };
    var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {
      var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
      ];
      var TA = typeMapping[dataTypeIndex];
      function decodeMemoryView(handle) {
        var size = HEAPU32[handle >> 2];
        var data = HEAPU32[(handle + 4) >> 2];
        return new TA(HEAP8.buffer, data, size);
      }
      name = readLatin1String(name);
      registerType(
        rawType,
        {
          name: name,
          fromWireType: decodeMemoryView,
          argPackAdvance: GenericWireTypeSize,
          readValueFromPointer: decodeMemoryView,
        },
        { ignoreDuplicateRegistrations: true },
      );
    };
    var __embind_register_optional = (rawOptionalType, rawType) => {
      __embind_register_emval(rawOptionalType);
    };
    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | (u >> 6);
          heap[outIdx++] = 128 | (u & 63);
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | (u >> 12);
          heap[outIdx++] = 128 | ((u >> 6) & 63);
          heap[outIdx++] = 128 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | (u >> 18);
          heap[outIdx++] = 128 | ((u >> 12) & 63);
          heap[outIdx++] = 128 | ((u >> 6) & 63);
          heap[outIdx++] = 128 | (u & 63);
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
    var stringToUTF8 = (str, outPtr, maxBytesToWrite) =>
      stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
    var UTF8Decoder =
      typeof TextDecoder != "undefined" ? new TextDecoder() : undefined;
    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode(((u0 & 31) << 6) | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 =
            ((u0 & 7) << 18) |
            (u1 << 12) |
            (u2 << 6) |
            (heapOrArray[idx++] & 63);
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
        }
      }
      return str;
    };
    var UTF8ToString = (ptr, maxBytesToRead) =>
      ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    var __embind_register_std_string = (rawType, name) => {
      name = readLatin1String(name);
      var stdStringIsUTF8 = name === "std::string";
      registerType(rawType, {
        name: name,
        fromWireType(value) {
          var length = HEAPU32[value >> 2];
          var payload = value + 4;
          var str;
          if (stdStringIsUTF8) {
            var decodeStartPtr = payload;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = payload + i;
              if (i == length || HEAPU8[currentBytePtr] == 0) {
                var maxRead = currentBytePtr - decodeStartPtr;
                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                if (str === undefined) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + 1;
              }
            }
          } else {
            var a = new Array(length);
            for (var i = 0; i < length; ++i) {
              a[i] = String.fromCharCode(HEAPU8[payload + i]);
            }
            str = a.join("");
          }
          _free(value);
          return str;
        },
        toWireType(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }
          var length;
          var valueIsOfTypeString = typeof value == "string";
          if (
            !(
              valueIsOfTypeString ||
              value instanceof Uint8Array ||
              value instanceof Uint8ClampedArray ||
              value instanceof Int8Array
            )
          ) {
            throwBindingError("Cannot pass non-string to std::string");
          }
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            length = lengthBytesUTF8(value);
          } else {
            length = value.length;
          }
          var base = _malloc(4 + length + 1);
          var ptr = base + 4;
          HEAPU32[base >> 2] = length;
          if (stdStringIsUTF8 && valueIsOfTypeString) {
            stringToUTF8(value, ptr, length + 1);
          } else {
            if (valueIsOfTypeString) {
              for (var i = 0; i < length; ++i) {
                var charCode = value.charCodeAt(i);
                if (charCode > 255) {
                  _free(ptr);
                  throwBindingError(
                    "String has UTF-16 code units that do not fit in 8 bits",
                  );
                }
                HEAPU8[ptr + i] = charCode;
              }
            } else {
              for (var i = 0; i < length; ++i) {
                HEAPU8[ptr + i] = value[i];
              }
            }
          }
          if (destructors !== null) {
            destructors.push(_free, base);
          }
          return base;
        },
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        },
      });
    };
    var UTF16Decoder =
      typeof TextDecoder != "undefined"
        ? new TextDecoder("utf-16le")
        : undefined;
    var UTF16ToString = (ptr, maxBytesToRead) => {
      var endPtr = ptr;
      var idx = endPtr >> 1;
      var maxIdx = idx + maxBytesToRead / 2;
      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
      endPtr = idx << 1;
      if (endPtr - ptr > 32 && UTF16Decoder)
        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
      var str = "";
      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
        var codeUnit = HEAP16[(ptr + i * 2) >> 1];
        if (codeUnit == 0) break;
        str += String.fromCharCode(codeUnit);
      }
      return str;
    };
    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite =
        maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        var codeUnit = str.charCodeAt(i);
        HEAP16[outPtr >> 1] = codeUnit;
        outPtr += 2;
      }
      HEAP16[outPtr >> 1] = 0;
      return outPtr - startPtr;
    };
    var lengthBytesUTF16 = (str) => str.length * 2;
    var UTF32ToString = (ptr, maxBytesToRead) => {
      var i = 0;
      var str = "";
      while (!(i >= maxBytesToRead / 4)) {
        var utf32 = HEAP32[(ptr + i * 4) >> 2];
        if (utf32 == 0) break;
        ++i;
        if (utf32 >= 65536) {
          var ch = utf32 - 65536;
          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
        } else {
          str += String.fromCharCode(utf32);
        }
      }
      return str;
    };
    var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343) {
          var trailSurrogate = str.charCodeAt(++i);
          codeUnit =
            (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);
        }
        HEAP32[outPtr >> 2] = codeUnit;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      HEAP32[outPtr >> 2] = 0;
      return outPtr - startPtr;
    };
    var lengthBytesUTF32 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
        len += 4;
      }
      return len;
    };
    var __embind_register_std_wstring = (rawType, charSize, name) => {
      name = readLatin1String(name);
      var decodeString, encodeString, readCharAt, lengthBytesUTF;
      if (charSize === 2) {
        decodeString = UTF16ToString;
        encodeString = stringToUTF16;
        lengthBytesUTF = lengthBytesUTF16;
        readCharAt = (pointer) => HEAPU16[pointer >> 1];
      } else if (charSize === 4) {
        decodeString = UTF32ToString;
        encodeString = stringToUTF32;
        lengthBytesUTF = lengthBytesUTF32;
        readCharAt = (pointer) => HEAPU32[pointer >> 2];
      }
      registerType(rawType, {
        name: name,
        fromWireType: (value) => {
          var length = HEAPU32[value >> 2];
          var str;
          var decodeStartPtr = value + 4;
          for (var i = 0; i <= length; ++i) {
            var currentBytePtr = value + 4 + i * charSize;
            if (i == length || readCharAt(currentBytePtr) == 0) {
              var maxReadBytes = currentBytePtr - decodeStartPtr;
              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
              if (str === undefined) {
                str = stringSegment;
              } else {
                str += String.fromCharCode(0);
                str += stringSegment;
              }
              decodeStartPtr = currentBytePtr + charSize;
            }
          }
          _free(value);
          return str;
        },
        toWireType: (destructors, value) => {
          if (!(typeof value == "string")) {
            throwBindingError(
              `Cannot pass non-string to C++ string type ${name}`,
            );
          }
          var length = lengthBytesUTF(value);
          var ptr = _malloc(4 + length + charSize);
          HEAPU32[ptr >> 2] = length / charSize;
          encodeString(value, ptr + 4, length + charSize);
          if (destructors !== null) {
            destructors.push(_free, ptr);
          }
          return ptr;
        },
        argPackAdvance: GenericWireTypeSize,
        readValueFromPointer: readPointer,
        destructorFunction(ptr) {
          _free(ptr);
        },
      });
    };
    var __embind_register_void = (rawType, name) => {
      name = readLatin1String(name);
      registerType(rawType, {
        isVoid: true,
        name: name,
        argPackAdvance: 0,
        fromWireType: () => undefined,
        toWireType: (destructors, o) => undefined,
      });
    };
    var __emscripten_memcpy_js = (dest, src, num) =>
      HEAPU8.copyWithin(dest, src, src + num);
    var requireRegisteredType = (rawType, humanName) => {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
        throwBindingError(
          `${humanName} has unknown type ${getTypeName(rawType)}`,
        );
      }
      return impl;
    };
    var __emval_take_value = (type, arg) => {
      type = requireRegisteredType(type, "_emval_take_value");
      var v = type["readValueFromPointer"](arg);
      return Emval.toHandle(v);
    };
    var getHeapMax = () => 2097152e3;
    var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = (size - b.byteLength + 65535) / 65536;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {}
    };
    var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      var alignUp = (x, multiple) =>
        x + ((multiple - (x % multiple)) % multiple);
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(
          overGrownHeapSize,
          requestedSize + 100663296,
        );
        var newSize = Math.min(
          maxHeapSize,
          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),
        );
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    };
    var getCFunc = (ident) => {
      var func = Module["_" + ident];
      return func;
    };
    var writeArrayToMemory = (array, buffer) => {
      HEAP8.set(array, buffer);
    };
    var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
    var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };
    var ccall = (ident, returnType, argTypes, args, opts) => {
      var toC = {
        string: (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) {
            ret = stringToUTF8OnStack(str);
          }
          return ret;
        },
        array: (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        },
      };
      function convertReturnValue(ret) {
        if (returnType === "string") {
          return UTF8ToString(ret);
        }
        if (returnType === "boolean") return Boolean(ret);
        return ret;
      }
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func(...cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }
      ret = onDone(ret);
      return ret;
    };
    var cwrap = (ident, returnType, argTypes, opts) => {
      var numericArgs =
        !argTypes ||
        argTypes.every((type) => type === "number" || type === "boolean");
      var numericRet = returnType !== "string";
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return (...args) => ccall(ident, returnType, argTypes, args, opts);
    };
    embind_init_charCodes();
    BindingError = Module["BindingError"] = class BindingError extends Error {
      constructor(message) {
        super(message);
        this.name = "BindingError";
      }
    };
    InternalError = Module["InternalError"] = class InternalError extends (
      Error
    ) {
      constructor(message) {
        super(message);
        this.name = "InternalError";
      }
    };
    init_ClassHandle();
    init_embind();
    init_RegisteredPointer();
    UnboundTypeError = Module["UnboundTypeError"] = extendError(
      Error,
      "UnboundTypeError",
    );
    init_emval();
    var wasmImports = {
      j: ___cxa_throw,
      p: __abort_js,
      o: __embind_register_bigint,
      k: __embind_register_bool,
      g: __embind_register_class,
      f: __embind_register_class_constructor,
      c: __embind_register_class_function,
      s: __embind_register_emval,
      i: __embind_register_float,
      t: __embind_register_function,
      d: __embind_register_integer,
      b: __embind_register_memory_view,
      n: __embind_register_optional,
      h: __embind_register_std_string,
      e: __embind_register_std_wstring,
      l: __embind_register_void,
      r: __emscripten_memcpy_js,
      m: __emval_take_value,
      q: _emscripten_resize_heap,
      a: wasmMemory,
    };
    var wasmExports = createWasm();
    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["u"])();
    var ___getTypeName = (a0) => (___getTypeName = wasmExports["w"])(a0);
    var _malloc = (a0) => (_malloc = wasmExports["x"])(a0);
    var _free = (a0) => (_free = wasmExports["y"])(a0);
    var __emscripten_stack_restore = (a0) =>
      (__emscripten_stack_restore = wasmExports["z"])(a0);
    var __emscripten_stack_alloc = (a0) =>
      (__emscripten_stack_alloc = wasmExports["A"])(a0);
    var _emscripten_stack_get_current = () =>
      (_emscripten_stack_get_current = wasmExports["B"])();
    var ___cxa_is_pointer_type = (a0) =>
      (___cxa_is_pointer_type = wasmExports["C"])(a0);
    Module["ccall"] = ccall;
    Module["cwrap"] = cwrap;
    var calledRun;
    dependenciesFulfilled = function runCaller() {
      if (!calledRun) run();
      if (!calledRun) dependenciesFulfilled = runCaller;
    };
    function run() {
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun) return;
        calledRun = true;
        Module["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        readyPromiseResolve(Module);
        Module["onRuntimeInitialized"]?.();
        postRun();
      }
      if (Module["setStatus"]) {
        Module["setStatus"]("Running...");
        setTimeout(function () {
          setTimeout(function () {
            Module["setStatus"]("");
          }, 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function")
        Module["preInit"] = [Module["preInit"]];
      while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }
    run();
    moduleRtn = readyPromise;

    return moduleRtn;
  };
})();
export default Module;
